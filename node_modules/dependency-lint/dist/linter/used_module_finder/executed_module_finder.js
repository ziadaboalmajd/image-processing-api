"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.default = void 0;

var _lodash = _interopRequireDefault(require("lodash"));

var _fsExtra = require("fs-extra");

var _module_name_parser = _interopRequireDefault(require("./module_name_parser"));

var _path = _interopRequireDefault(require("path"));

var _bluebird = _interopRequireDefault(require("bluebird"));

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

const glob = _bluebird.default.promisify(require('glob'));

class ExecutedModulesFinder {
  constructor({
    shellScripts: shellScripts
  }) {
    this.findModuleExecutableUsage = this.findModuleExecutableUsage.bind(this);
    this.shellScripts = shellScripts;
  }

  async find({
    dir: dir,
    packageJson: packageJson
  }) {
    const installedModules = _lodash.default.keys(packageJson.devDependencies).concat(_lodash.default.keys(packageJson.dependencies));

    const [moduleExecutables, shellScripts] = await _bluebird.default.all([this.getModuleExecutables(installedModules, dir), this.readShellScripts(dir)]);
    const packageJsonScripts = packageJson.scripts || {};
    return this.findModuleExecutableUsage({
      moduleExecutables: moduleExecutables,
      packageJsonScripts: packageJsonScripts,
      shellScripts: shellScripts
    });
  }

  findInScript(script, moduleExecutables) {
    const result = [];

    for (const name in moduleExecutables) {
      const executables = moduleExecutables[name];

      for (const executable of Array.from(executables)) {
        if (_module_name_parser.default.isGlobalExecutable(executable)) {
          continue;
        }

        if (script.match(`\\b${executable}\\b`) && !Array.from(result).includes(name)) {
          result.push(name);
        }
      }
    }

    return result;
  }

  findModuleExecutableUsage({
    moduleExecutables: moduleExecutables,
    packageJsonScripts: packageJsonScripts,
    shellScripts: shellScripts
  }) {
    let moduleName;
    const result = [];

    for (const scriptName in packageJsonScripts) {
      const script = packageJsonScripts[scriptName];

      for (moduleName of Array.from(this.findInScript(script, moduleExecutables))) {
        result.push({
          name: moduleName,
          script: scriptName
        });
      }
    }

    for (const filePath in shellScripts) {
      const fileContent = shellScripts[filePath];

      for (moduleName of Array.from(this.findInScript(fileContent, moduleExecutables))) {
        result.push({
          name: moduleName,
          file: filePath
        });
      }
    }

    return result;
  }

  async getModuleExecutables(installedModules, dir) {
    const nodeModulesPath = _path.default.join(dir, 'node_modules');

    const files = installedModules.map(x => _path.default.join(nodeModulesPath, x, 'package.json'));
    return _lodash.default.fromPairs((await _bluebird.default.map(files, this.getModuleExecutablesPair)));
  }

  async getModuleExecutablesPair(packageJsonPath) {
    const packageJson = await (0, _fsExtra.readJson)(packageJsonPath);
    let executables = [];

    if (_lodash.default.isString(packageJson.bin)) {
      executables = [packageJson.name];
    } else if (_lodash.default.isObject(packageJson.bin)) {
      executables = _lodash.default.keys(packageJson.bin);
    }

    return [packageJson.name, executables];
  }

  async readShellScripts(dir, done) {
    const filePaths = await glob(this.shellScripts.root, {
      cwd: dir,
      ignore: this.shellScripts.ignore
    });

    const fileMapping = _lodash.default.fromPairs(filePaths.map(function (filePath) {
      const fileContentPromise = (0, _fsExtra.readFile)(_path.default.join(dir, filePath), 'utf8');
      return [filePath, fileContentPromise];
    }));

    return _bluebird.default.props(fileMapping);
  }

}

exports.default = ExecutedModulesFinder;