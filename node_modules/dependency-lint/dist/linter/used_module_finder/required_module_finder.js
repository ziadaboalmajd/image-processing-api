"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.default = void 0;

var _lodash = _interopRequireDefault(require("lodash"));

var _detective = _interopRequireDefault(require("detective"));

var _detectiveEs = _interopRequireDefault(require("detective-es6"));

var _fsExtra = require("fs-extra");

var _module_name_parser = _interopRequireDefault(require("./module_name_parser"));

var _path = _interopRequireDefault(require("path"));

var _prepend_to_error = _interopRequireDefault(require("../../util/prepend_to_error"));

var _bluebird = _interopRequireDefault(require("bluebird"));

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

const glob = _bluebird.default.promisify(require('glob'));

class RequiredModuleFinder {
  constructor({
    acornParseProps: acornParseProps,
    files: files,
    stripLoaders: stripLoaders,
    transpilers: transpilers
  }) {
    this.acornParseProps = acornParseProps;
    this.files = files;
    this.stripLoaders = stripLoaders;
    this.transpilers = transpilers;
  }

  compileIfNeeded({
    content: content,
    dir: dir,
    filePath: filePath
  }) {
    const ext = _path.default.extname(filePath);

    const transpiler = _lodash.default.find(this.transpilers, ['extension', ext]);

    if (transpiler) {
      const compiler = require(transpiler.module);

      const fnName = transpiler.fnName || 'compile';
      let result = compiler[fnName](content, {
        cwd: dir,
        filename: _path.default.join(dir, filePath)
      });

      if (transpiler.resultKey) {
        result = result[transpiler.resultKey];
      }

      return result;
    } else {
      return content;
    }
  }

  async find(dir) {
    const files = await glob(this.files.root, {
      cwd: dir,
      ignore: this.files.ignore
    });
    const results = await _bluebird.default.map(files, filePath => this.findInFile({
      dir: dir,
      filePath: filePath
    }));
    return _lodash.default.flatten(results);
  }

  async findInFile({
    dir: dir,
    filePath: filePath
  }) {
    let moduleNames;
    let content = await (0, _fsExtra.readFile)(_path.default.join(dir, filePath), 'utf8');

    try {
      content = this.compileIfNeeded({
        content: content,
        dir: dir,
        filePath: filePath
      });
      const cjsModuleNames = (0, _detective.default)(content, {
        parse: this.acornParseProps,
        isRequire: this.isRequire.bind(this)
      });
      const importModulesNames = (0, _detectiveEs.default)(content);
      moduleNames = cjsModuleNames.concat(importModulesNames);
    } catch (err) {
      throw (0, _prepend_to_error.default)(err, filePath);
    }

    return moduleNames = this.normalizeModuleNames({
      filePath: filePath,
      moduleNames: moduleNames
    });
  }

  isRequire({
    type: type,
    callee: callee
  }) {
    return type === 'CallExpression' && (callee.type === 'Identifier' && callee.name === 'require' || callee.type === 'MemberExpression' && callee.object.type === 'Identifier' && callee.object.name === 'require' && callee.property.type === 'Identifier' && callee.property.name === 'resolve');
  }

  normalizeModuleNames({
    filePath: filePath,
    moduleNames: moduleNames
  }) {
    return _lodash.default.chain(moduleNames).map(this.stripLoaders ? _module_name_parser.default.stripLoaders : undefined).reject(_module_name_parser.default.isRelative).map(_module_name_parser.default.stripSubpath).reject(_module_name_parser.default.isBuiltIn).map(name => ({
      name: name,
      file: filePath
    })).value();
  }

}

exports.default = RequiredModuleFinder;
module.exports = RequiredModuleFinder;