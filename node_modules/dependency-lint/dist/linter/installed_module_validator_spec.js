"use strict";

var _fsExtra = require("fs-extra");

var _get_tmp_dir = _interopRequireDefault(require("../../test/support/get_tmp_dir"));

var _installed_module_validator = _interopRequireDefault(require("./installed_module_validator"));

var _path = _interopRequireDefault(require("path"));

var _bluebird = _interopRequireDefault(require("bluebird"));

var _mocha = require("mocha");

var _chai = require("chai");

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

const examples = [{
  description: 'dependency not installed',
  expectedErrorMessage: `\
The following modules listed in your \`package.json\` have issues:
  myModule (not installed)
All modules need to be installed with the correct semantic version
to properly check for the usage of a module's executables.\
`,
  packageJson: {
    dependencies: {
      myModule: '^1.0.0'
    }
  }
}, {
  description: 'devDependency not installed',
  expectedErrorMessage: `\
The following modules listed in your \`package.json\` have issues:
  myModule (not installed)
All modules need to be installed with the correct semantic version
to properly check for the usage of a module's executables.\
`,
  packageJson: {
    devDependencies: {
      myModule: '^1.0.0'
    }
  }
}, {
  description: 'dependency wrong version installed',
  expectedErrorMessage: `\
The following modules listed in your \`package.json\` have issues:
  myModule (installed: 2.0.0, listed: ^1.0.0)
All modules need to be installed with the correct semantic version
to properly check for the usage of a module's executables.\
`,
  installedModules: [{
    name: 'myModule',
    version: '2.0.0'
  }],
  packageJson: {
    dependencies: {
      myModule: '^1.0.0'
    }
  }
}, {
  description: 'devDependency wrong version installed',
  expectedErrorMessage: `\
The following modules listed in your \`package.json\` have issues:
  myModule (installed: 2.0.0, listed: ^1.0.0)
All modules need to be installed with the correct semantic version
to properly check for the usage of a module's executables.\
`,
  installedModules: [{
    name: 'myModule',
    version: '2.0.0'
  }],
  packageJson: {
    devDependencies: {
      myModule: '^1.0.0'
    }
  }
}, {
  description: 'dependency not installed through registry',
  installedModules: [{
    name: 'myModule',
    version: '1.0.0'
  }],
  packageJson: {
    dependencies: {
      myModule: 'git+ssh://git@host:myOrganization/myModule.git#1.0.0"'
    }
  }
}, {
  description: 'devDependency not installed through registry',
  installedModules: [{
    name: 'myModule',
    version: '1.0.0'
  }],
  packageJson: {
    devDependencies: {
      myModule: 'git+ssh://git@host:myOrganization/myModule.git#1.0.0"'
    }
  }
}, {
  description: 'validate the version specified in dependencies',
  installedModules: [{
    name: 'myModule',
    version: '0.9.1'
  }],
  packageJson: {
    dependencies: {
      myModule: '0.9.1'
    },
    devDependencies: {
      myModule: '1.0.0'
    }
  }
}];
(0, _mocha.describe)('InstalledModuleValidator', function () {
  (0, _mocha.beforeEach)(function () {
    this.installedModuleValidator = new _installed_module_validator.default();
  });
  (0, _mocha.describe)('validate', function () {
    (0, _mocha.beforeEach)(async function () {
      this.tmpDir = await (0, _get_tmp_dir.default)();
    });
    examples.forEach(({
      description: description,
      expectedErrorMessage: expectedErrorMessage,
      packageJson: packageJson,
      installedModules: installedModules
    }) => (0, _mocha.describe)(description, function () {
      (0, _mocha.beforeEach)(async function () {
        const promises = [];

        let packageJsonPath = _path.default.join(this.tmpDir, 'package.json');

        promises.push((0, _fsExtra.writeJson)(packageJsonPath, packageJson));

        if (installedModules) {
          installedModules.forEach(({
            name: name,
            version: version
          }) => {
            packageJsonPath = _path.default.join(this.tmpDir, 'node_modules', name, 'package.json');
            promises.push((0, _fsExtra.outputJson)(packageJsonPath, {
              name: name,
              version: version
            }));
          });
        }

        await _bluebird.default.all(promises);

        try {
          await this.installedModuleValidator.validate({
            dir: this.tmpDir,
            packageJson: packageJson
          });
        } catch (error) {
          this.error = error;
        }
      });

      if (expectedErrorMessage) {
        (0, _mocha.it)('returns the expected error', function () {
          (0, _chai.expect)(this.error.message).to.eql(expectedErrorMessage);
        });
      } else {
        (0, _mocha.it)('does not yield an error', function () {
          (0, _chai.expect)(this.error).to.not.exist();
        });
      }
    }));
  });
});