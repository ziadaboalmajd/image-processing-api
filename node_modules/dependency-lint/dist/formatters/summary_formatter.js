"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.default = void 0;

var _lodash = _interopRequireDefault(require("lodash"));

var _safe = _interopRequireDefault(require("colors/safe"));

var _error_messages = _interopRequireDefault(require("./error_messages"));

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

class SummaryFormatter {
  // stream - writable stream to send output
  constructor({
    minimal: minimal,
    stream: stream
  }) {
    this.minimal = minimal;
    this.stream = stream;
  } // Prints the result to its stream


  print({
    fixes: fixes,
    results: results
  }) {
    if (!fixes) {
      fixes = {};
    }

    for (const type in results) {
      let modules = results[type];

      if (this.minimal) {
        modules = _lodash.default.filter(modules, ({
          error: error,
          errorIgnored: errorIgnored
        }) => error && !errorIgnored);
      }

      if (modules.length === 0) {
        continue;
      }

      this.write(`${type}:`);

      for (const module of modules) {
        const fixed = _lodash.default.includes(fixes[type], module.name);

        this.write(this.moduleOutput(module, fixed), 1);
      }

      this.write('');
    }

    if (!this.minimal || this.errorCount(results) !== 0) {
      this.write(this.summaryOutput(results));
    }
  }

  moduleOutput({
    error: error,
    errorIgnored: errorIgnored,
    files: files,
    name: name,
    scripts: scripts
  }, fixed) {
    if (error) {
      const message = _error_messages.default[error];

      if (errorIgnored) {
        return _safe.default.yellow(`- ${name} (${message} - ignored)`);
      } else {
        const header = fixed ? _safe.default.magenta(`✖ ${name} (${message} - fixed)`) : _safe.default.red(`✖ ${name} (${message})`);
        return header + _safe.default.gray(this.errorSuffix({
          files: files,
          scripts: scripts
        }));
      }
    } else {
      return `${_safe.default.green('✓')} ${name}`;
    }
  }

  indent(str, count) {
    let prefix = '';

    _lodash.default.times(count, () => prefix += '  ');

    return prefix + str;
  }

  write(data, indent) {
    if (indent == null) {
      indent = 0;
    }

    data = data.split('\n').map(str => this.indent(str, indent)).join('\n') + '\n';
    return this.stream.write(data, 'utf8');
  }

  errorCount(results) {
    let count = 0;

    for (const title in results) {
      const modules = results[title];

      for (const {
        error: error,
        errorIgnored: errorIgnored
      } of modules) {
        if (error && !errorIgnored) {
          count += 1;
        }
      }
    }

    return count;
  }

  errorSuffix(usage) {
    let suffix = '';

    for (const type in usage) {
      const list = usage[type];

      if (list && list.length > 0) {
        suffix += `\n${this.indent(`used in ${type}:`, 2)}`;

        for (const item of list) {
          suffix += `\n${this.indent(item, 3)}`;
        }
      }
    }

    return suffix;
  }

  summaryOutput(results) {
    const errors = this.errorCount(results);

    let prefix = _safe.default.green('✓');

    if (errors > 0) {
      prefix = _safe.default.red('✖');
    }

    let msg = `${prefix} ${errors} error`;

    if (errors !== 1) {
      msg += 's';
    }

    return msg;
  }

}

exports.default = SummaryFormatter;